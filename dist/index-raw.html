<html><head>
    <title>Find all the joiners!</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>*{
  user-select:none;
}
#bio{
  position:absolute;
  top:0;
  left:0;
  bottom:0;
  right:0;
  display:none;
  background-color:rgba(0, 0, 0, 0.9);
  pointer-events:none;
  overflow:scroll;
  padding:18px;
}
.bio #bio{
  display:block;
}
html,
body{
  margin:0;
  padding:0;
}
body,
#M{
  align-items:center;
  display:flex;
  justify-content:center;
  height:100%;
  text-align:center;
  font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  background:#000;
}
body{
  text-shadow:0px 0px 8px #000, -1px -1px 3px #000, 1px 1px 3px #000;
  color:rgba(255, 255, 255, 0.9);
}
#M{
  position:relative;
  letter-spacing:0.01em;
}
input{
  width:1.2rem;
  height:1.2rem;
  vertical-align:middle;
}
#V{
  width:15em;
}
#N{
  position:absolute;
  top:0;
}
#N{
  display:none;
  width:100%;
  height:100%;
  backdrop-filter:blur(15px) contrast(200%) brightness(35%);
}
b{
  cursor:pointer;
}
b:hover{
  text-decoration:underline;
}
.X{
  opacity:0.5;
  cursor:no-drop;
}
.X:hover{
  text-decoration:none;
}
#T{
  padding:2px;
  bottom:0;
  position:absolute;
}
h1,
h3{
  margin:0.2em;
}
small{
  display:block;
  margin:0.55em;
}
label{
  margin:0.4em;
}
@-moz-document url-prefix(){
.N #C{
    filter:blur(15px) contrast(190%) brightness(50%);
}
}
#found-text{
  position:absolute;
  top:8px;
  left:8px;
  right:8px;
  font-size:0.8em;
  text-align:right;
}
#found-text b{
  text-shadow:0px 0px 3px #000;
}
.N #T,
.N #bio,
.N #found-text,
.bio #found-text,
.bio #T{
  display:none;
}
.N #N{
  display:block;
}
a,
a:visited,
a:active{
  opacity:0.7;
  font-size:0.6em;
  color:#fca;
}
a:hover{
  opacity:1;
}
</style></head>

  <body class="L">
    <div id="M">
      <canvas id="C"></canvas>
      <div id="found-text"></div>
      <div id="T">
        <h1>Loading...</h1>
      </div>
      <div id="N">
        <h1>Find all the joiners!</h1>
        <h3><b id="R">New Game</b></h3>
        <h3><b id="S" class="X">Save Game</b></h3>
        <h3><b id="L">Load Game</b></h3>
        <small>
          <label><input type="checkbox" id="Y"> Invert Y </label>
          <label> <input type="checkbox" id="Q" checked> High quality </label>
          <label> <input type="checkbox" id="H" checked> Head Bob </label><br>
          <label>Mouse sensitivity <input type="range" id="V" value="28"></label>
          <br>
          <br>
          Shift: run<br>
          W,A,S,D/Arrows: move, strafe<br>
          Mouse: look around<br>
          E,Space: interact<br>
          Esc,M: menu
        </small>
      </div>
    </div>
    <div id="bio">
      <div id="bioc"></div>
      <footer>[Press E or Space to continue]</footer>
    </div>
  
  

<script>function __js_load_modules__(){(function() {
  const {
    abs,
    acos,
    acosh,
    asin,
    asinh,
    atan,
    atanh,
    atan2,
    ceil,
    cbrt,
    expm1,
    clz32,
    cos,
    cosh,
    exp,
    floor,
    fround,
    hypot,
    imul,
    log,
    log1p,
    log2,
    log10,
    max,
    min,
    random,
    round,
    sign,
    sin,
    sinh,
    sqrt,
    tan,
    tanh,
    trunc,
    E,
    LN10,
    LN2,
    LOG10E,
    LOG2E,
    PI,
    SQRT1_2,
    SQRT2
  } = Math;
  const TWO_PI = PI * 2;
  const DEG_TO_RAD = PI / 180;
  const lerp = (from, to, t) => from + t * (to - from);
  const clamp = (value, minimum, maximum) => min(max(value, minimum), maximum);
  const wrapAngleInRadians = (angle) => angle - TWO_PI * floor((angle + PI) / TWO_PI);
  const scalarAdd = (a, b) => a + b;
  const scalarSubtract = (a, b) => a - b;
  const scalarMultiply = (a, b) => a * b;
  const scalarDivide = (a, b) => a / b;
  const unpackFloatBytes4 = (r, g, b, a) => {
    return r / 255 + g / 65025 + b / 16581375 + a / 40948250625;
  };
  const {
    assign: objectAssign,
    getOwnPropertyDescriptor: objectGetOwnPropertyDescriptor,
    getOwnPropertyDescriptors: objectGetOwnPropertyDescriptors,
    getOwnPropertyNames: objectGetOwnPropertyNames,
    getOwnPropertySymbols: objectGetOwnPropertySymbols,
    is: objectIs,
    preventExtensions: objectPreventExtensions,
    seal: objectSeal,
    create: objectCreate,
    defineProperties: objectDefineProperties,
    defineProperty: objectDefineProperty,
    freeze: objectFreeze,
    getPrototypeOf: objectGetPrototypeOf,
    setPrototypeOf: objectSetPrototypeOf,
    isExtensible: objectIsExtensible,
    isFrozen: objectIsFrozen,
    isSealed: objectIsSealed,
    keys: objectKeys,
    entries: objectEntries,
    fromEntries: objectFromEntries,
    values: objectValues
  } = Object;
  const debug_trycatch_wrap = (fn, _info) => fn;
  const KEY_FORWARD = 1;
  const KEY_BACKWARD = 2;
  const KEY_STRAFE_LEFT = 3;
  const KEY_STRAFE_RIGHT = 4;
  const KEY_RUN = 5;
  const KEY_ACTION = 6;
  const KEY_MAIN_MENU = 8;
  const PressedKeys = [];
  const KeyFunctions = {};
  const _keyMap = {
    w: KEY_FORWARD,
    W: KEY_FORWARD,
    z: KEY_FORWARD,
    Z: KEY_FORWARD,
    ArrowUp: KEY_FORWARD,
    s: KEY_BACKWARD,
    S: KEY_BACKWARD,
    ArrowDown: KEY_BACKWARD,
    a: KEY_STRAFE_LEFT,
    A: KEY_STRAFE_LEFT,
    q: KEY_STRAFE_LEFT,
    Q: KEY_STRAFE_LEFT,
    ArrowLeft: KEY_STRAFE_LEFT,
    d: KEY_STRAFE_RIGHT,
    D: KEY_STRAFE_RIGHT,
    ArrowRight: KEY_STRAFE_RIGHT,
    Shift: KEY_RUN,
    e: KEY_ACTION,
    E: KEY_ACTION,
    " ": KEY_ACTION,
    Escape: KEY_MAIN_MENU,
    M: KEY_MAIN_MENU,
    m: KEY_MAIN_MENU
  };
  const _setKeyPressed = (e, value) => {
    if (!e.keyCode || e.metaKey || !document.activeElement || mainMenuVisible) {
      PressedKeys.length = 0;
    } else {
      const keyId = _keyMap[e.key] | 0;
      if (value && KeyFunctions[keyId]) {
        KeyFunctions[keyId](e.repeat);
      }
      PressedKeys[keyId] = value;
    }
  };
  onkeydown = (ev) => _setKeyPressed(ev, true);
  onkeyup = (ev) => _setKeyPressed(ev, false);
  const vec3New = (x, y, z) => ({x, y, z});
  const vec3NewValue = (value = 0) => ({x: value, y: value, z: value});
  const vec3Temp0 = vec3NewValue();
  const vec3Temp1 = vec3NewValue();
  const VEC3_UNIT_Y = vec3New(0, 1, 0);
  const vec3Set = (out, x, y, z) => {
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
  };
  const vec3SetEachVecVec = (out, {x, y, z}, b, fn) => vec3Set(out, fn(x, b.x), fn(y, b.y), fn(z, b.z));
  const vec3SetEachVecScalar = (out, {x, y, z}, b, fn) => vec3Set(out, fn(x, b), fn(y, b), fn(z, b));
  const vec3Dot = ({x, y, z}, b) => x * b.x + y * b.y + z * b.z;
  const vec3LengthSquared = ({x, y, z}) => x ** 2 + y ** 2 + z ** 2;
  const vec3Length = (a) => sqrt(vec3LengthSquared(a));
  const vec3DistanceSquared = ({x, y, z}, b) => (b.x - x) ** 2 + (b.y - y) ** 2 + (b.z - z) ** 2;
  const vec3Distance = (a, b) => sqrt(vec3DistanceSquared(a, b));
  const vec3Add = (out, a, b = out) => vec3SetEachVecVec(out, a, b, scalarAdd);
  const vec3Subtract = (out, a, b) => vec3SetEachVecVec(out, a, b, scalarSubtract);
  const vec3ScalarMultiply = (out, b, a = out) => vec3SetEachVecScalar(out, a, b, scalarMultiply);
  const vec3DivideScalar = (out, a, b) => vec3SetEachVecScalar(out, a, b, scalarDivide);
  const vec3Normalize = (out, a = out) => vec3DivideScalar(out, a, vec3Length(a));
  const vec3Direction = (out, a, b) => vec3Normalize(vec3Subtract(out, b, a));
  const vec3Cross = (out, {x, y, z}, {x: bx, y: by, z: bz}) => vec3Set(out, y * bz - z * by, z * bx - x * bz, x * by - y * bx);
  const vec2New = (x, y) => ({x, y});
  const vec2Set = (out, x, y) => {
    out.x = x;
    out.y = y;
    return out;
  };
  const typedArraySet = (array, ...values) => array.set(values);
  const MAX_GAME_TIME_DELTA_PER_FRAME = 0.033;
  let gameTime = 0;
  let gameTimeDelta = MAX_GAME_TIME_DELTA_PER_FRAME;
  let globalTime = 0;
  let renderDuringPausedGameTime = 0;
  const updateTime = (browserTimeInMilliseconds, paused) => {
    const newGlobalTime = browserTimeInMilliseconds / 1e3;
    const globalTimeDiff = newGlobalTime - globalTime;
    globalTime = newGlobalTime;
    if (paused) {
      gameTimeDelta = 0;
      if (newGlobalTime - renderDuringPausedGameTime >= 0.2) {
        renderDuringPausedGameTime = newGlobalTime;
        return true;
      }
      return false;
    }
    gameTimeDelta = min(globalTimeDiff, MAX_GAME_TIME_DELTA_PER_FRAME);
    gameTime += gameTimeDelta;
    return gameTimeDelta > 0;
  };
  const ANIMATIONS = {};
  const ANIMATIONS_LIST = objectValues(ANIMATIONS);
  let RUMBLING = false;
  function updateAnimations() {
    RUMBLING = false;
    for (const anim of ANIMATIONS_LIST) {
      if (anim._running) {
        if (anim._rumble) {
          RUMBLING = anim._rumble(anim._value);
        }
        anim._value += anim._speed * gameTimeDelta * anim._running;
        if (anim._value > anim._max || anim._value < anim._initial) {
          anim._value = anim._running > 0 ? anim._max : anim._initial;
          if (anim._onComplete) {
            anim._onComplete();
          }
          anim._running = 0;
        }
      }
    }
  }
  const EMPTY = {_text: "", _timeout: -1};
  let currentText = EMPTY;
  const textQueue = [];
  const clearTexts = () => {
    textQueue.length = 0;
    currentText = EMPTY;
    gameTextElement.innerHTML = "";
  };
  const setText = (text, timeout = -1) => {
    const textObject = text || timeout > 0 ? {_text: text, _timeout: timeout} : EMPTY;
    if (textQueue[0]) {
      if (timeout < 0) {
        textQueue[0] = textObject;
      } else {
        textQueue.splice(1, 0, textObject);
      }
    } else {
      textQueue.unshift(textObject);
      if (timeout > 0) {
        textQueue.unshift(EMPTY);
      }
    }
  };
  const updateText = () => {
    if (currentText && currentText._timeout > 0) {
      currentText._timeout -= gameTimeDelta;
    }
    if (currentText._timeout < 0 && textQueue[0]) {
      currentText = textQueue.pop();
      gameTextElement.innerHTML = currentText._text;
    }
  };
  const GAME_STATE = {
    _gameEnded: false,
    _bioIndex: -1,
    _foundCount: 0,
    _floppies: [
      newFloppy(18.33, 1.9562, 22.34),
      newFloppy(25.7, 1.9562, 22.5),
      newFloppy(36, 5.361, -12.6),
      newFloppy(47.1, 2.407, 0.14),
      newFloppy(-41.5, 2.805, 2.1),
      newFloppy(-47.8, 2.64, 13.6),
      newFloppy(-11.3, 6.308, -16.1),
      newFloppy(7.7, 12.2, 0.44),
      newFloppy(1.5, 15.805, -0.95)
    ]
  };
  function newFloppy(x, y, z, _lookAtDistance = 1.2) {
    return {
      _location: {x, y, z},
      _visible: true,
      _lookAtDistance,
      _onLookAt: () => "Pick up the floppy [press E or Space]",
      _onInteract() {
        this._visible = false;
        ++GAME_STATE._foundCount;
        GAME_STATE._bioIndex = GAME_STATE._floppies.indexOf(this);
      }
    };
  }
  const getVisibleObject = () => {
    const floppies = GAME_STATE._floppies;
    for (let i = 0; i < floppies.length; ++i) {
      const floppy = floppies[i];
      if (floppy._visible) {
        const objectLocation = floppy._location;
        if (vec3Distance(objectLocation, cameraPos) <= floppy._lookAtDistance) {
          if (vec3Dot(cameraDir, vec3Direction(vec3Temp0, cameraPos, objectLocation)) > 0.9) {
            return floppy;
          }
        }
      }
    }
    return void 0;
  };
  const endGame = () => {
    GAME_STATE._gameEnded = true;
    const t = gameTime * 0.2;
    const s = sin(gameTime * 0.4) * 9;
    vec3Set(cameraPos, sin(t) * 80 + s, 38, cos(t) * 40 + s);
    vec2Set(cameraEuler, t + PI, 23 * DEG_TO_RAD + cos(gameTime * 0.5) * 0.05);
    setText("");
  };
  let _actionWasPressed = false;
  const updateGameObjects = () => {
    if (!bioHtmlVisible) {
      if (GAME_STATE._foundCount >= GAME_STATE._floppies.length) {
        endGame();
      } else {
        const visibleObject = getVisibleObject();
        setText(visibleObject && visibleObject._onLookAt && visibleObject._onLookAt() || "");
        if (visibleObject && !_actionWasPressed && PressedKeys[KEY_ACTION] && visibleObject._onInteract) {
          visibleObject._onInteract();
        }
      }
    }
    _actionWasPressed = PressedKeys[KEY_ACTION];
  };
  const CAMERA_SPEED_DEFAULT = 2.1;
  const CAMERA_SPEED_RUN = 6;
  let headBob = 0;
  const cameraPos = vec3New(103, 44, 9);
  const cameraEuler = vec2New(-102 * DEG_TO_RAD, 23 * DEG_TO_RAD);
  const cameraDir = vec3NewValue();
  const cameraMat3 = new Float32Array(9);
  const movementForward = (direction) => vec3Add(vec3Temp0, vec3ScalarMultiply(vec3Normalize(vec3Set(vec3Temp1, cameraDir.x, 0, cameraDir.z)), direction));
  const movementStrafe = (direction) => vec3Add(vec3Temp0, vec3ScalarMultiply(vec3Normalize(vec3Cross(vec3Temp1, cameraDir, VEC3_UNIT_Y)), direction));
  const updateCameraDirFromEulerAngles = () => {
    let {x: yaw, y: pitch} = cameraEuler;
    if (RUMBLING) {
      yaw += sin(gameTime * 100) * 5e-3;
      pitch += sin(gameTime * 200) * 5e-3;
    }
    const sinYaw = sin(yaw);
    const cosYaw = cos(yaw);
    const sinPitch = sin(pitch);
    const cosPitch = cos(pitch);
    vec3Normalize(vec3Set(cameraDir, sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch));
    typedArraySet(cameraMat3, cosYaw, 0, -sinYaw, sinYaw * sinPitch, cosPitch, cosYaw * sinPitch, sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);
  };
  let timeMoving = 0;
  const updateCamera = () => {
    const speed = (PressedKeys[KEY_RUN] ? CAMERA_SPEED_RUN : CAMERA_SPEED_DEFAULT) * gameTimeDelta;
    if (!GAME_STATE._gameEnded && GAME_STATE._bioIndex < 0) {
      vec3Set(vec3Temp0, 0, 0, 0);
      if (PressedKeys[KEY_FORWARD]) {
        movementForward(1);
      }
      if (PressedKeys[KEY_BACKWARD]) {
        movementForward(-1);
      }
      if (PressedKeys[KEY_STRAFE_LEFT]) {
        movementStrafe(-1);
      }
      if (PressedKeys[KEY_STRAFE_RIGHT]) {
        movementStrafe(1);
      }
      if (vec3Temp0.x || vec3Temp0.z) {
        timeMoving += gameTimeDelta;
        headBob = headBobEnabled ? sin(timeMoving * 10) * 0.03 : 0;
        vec3Add(cameraPos, vec3ScalarMultiply(vec3Normalize(vec3Temp0), speed));
      }
    }
    updateCameraDirFromEulerAngles();
  };
  updateCameraDirFromEulerAngles();
  onmousemove = (e) => {
    if (document.pointerLockElement === canvasElement && !GAME_STATE._gameEnded) {
      const sens = lerp(4e-4, 31e-4, mouseSensitivity);
      cameraEuler.x = wrapAngleInRadians(cameraEuler.x - e.movementX * sens);
      cameraEuler.y = clamp(cameraEuler.y + e.movementY * mouseYInversion * sens, -87 * DEG_TO_RAD, 87 * DEG_TO_RAD);
    }
  };
  const bios_sp_html = '<ul>\n  <li>Bio html example</li>\n  <li>A bio goes here.</li>\n  <img src="./src/bios/sp.jpg">\n</ul>';
  const body = document.body;
  const canvasElement = document.getElementById("C");
  const gameTextElement = document.getElementById("T");
  const foundTextElement = document.getElementById("found-text");
  const MAIN_ELEMENT_PADDING = 30;
  const MAIN_ELEMENT_ASPECT_RATIO = 1.5;
  const MAIN_ELEMENT_MAX_WIDTH = 2e3;
  let mainMenuVisible;
  let renderWidth;
  let renderHeight;
  let mouseYInversion = 1;
  let headBobEnabled = true;
  let mouseSensitivity = 0.5;
  const mainElement = document.getElementById("M");
  const newGameButton = document.getElementById("R");
  const highQualityCheckbox = document.getElementById("Q");
  const invertYCheckbox = document.getElementById("Y");
  const mouseSensitivitySlider = document.getElementById("V");
  const headBobCheckbox = document.getElementById("H");
  const bioHtmlContentDiv = document.getElementById("bioc");
  const saveGameButton = document.getElementById("S");
  const loadGameButton = document.getElementById("L");
  const handleResize = () => {
    let cw = min(MAIN_ELEMENT_MAX_WIDTH, innerWidth - MAIN_ELEMENT_PADDING);
    let ch = innerHeight - MAIN_ELEMENT_PADDING;
    if (MAIN_ELEMENT_ASPECT_RATIO >= cw / ch) {
      ch = cw / MAIN_ELEMENT_ASPECT_RATIO;
    } else {
      cw = ch * MAIN_ELEMENT_ASPECT_RATIO;
    }
    const whStyles = {width: cw | 0, height: ch | 0, fontSize: `${ch / 23 | 0}px`};
    objectAssign(mainElement.style, whStyles);
    objectAssign(canvasElement.style, whStyles);
    let {clientWidth: w, clientHeight: h} = mainElement;
    if (!highQualityCheckbox.checked) {
      w = w / 2 | 0;
      h = h / 2 | 0;
    }
    renderWidth = w;
    renderHeight = h;
    canvasElement.width = w;
    canvasElement.height = h;
  };
  const showMainMenu = () => {
    mainMenuVisible = true;
    body.classList.add("N");
    document.exitPointerLock();
  };
  document.onpointerlockchange = () => {
    if (!document.pointerLockElement) {
      {
        showMainMenu();
      }
    }
  };
  const canvasRequestPointerLock = (e) => (!e || !e.button) && !mainMenuVisible && canvasElement.requestPointerLock();
  let gameStarted;
  const startOrResumeClick = (newGame = true) => {
    if (!gameStarted) {
      saveGameButton.className = "";
      if (newGame) {
        resetHtmlState();
        setText("Find all the floppy disks!", 2);
      }
      newGameButton.innerText = "Resume Game";
      vec3Set(cameraPos, 20, 8, 52);
      vec2Set(cameraEuler, 178.4 * DEG_TO_RAD, 0);
      gameStarted = true;
    }
    mainMenuVisible = false;
    body.classList.remove("N");
    canvasRequestPointerLock();
  };
  handleResize();
  onresize = handleResize;
  newGameButton.onclick = () => startOrResumeClick();
  KeyFunctions[KEY_MAIN_MENU] = showMainMenu;
  KeyFunctions[KEY_ACTION] = (repeat) => {
    if (!repeat) {
      GAME_STATE._bioIndex = -1;
    }
  };
  canvasElement.onmousedown = canvasRequestPointerLock;
  gameTextElement.onmousedown = canvasRequestPointerLock;
  highQualityCheckbox.onchange = handleResize;
  invertYCheckbox.onchange = () => {
    mouseYInversion = invertYCheckbox.checked ? -1 : 1;
  };
  headBobCheckbox.onchange = () => {
    headBobEnabled = headBobCheckbox.checked;
  };
  mouseSensitivitySlider.onchange = () => {
    mouseSensitivity = parseInt(mouseSensitivitySlider.value) / 100;
  };
  const gl = canvasElement.getContext("webgl2", {
    alpha: false,
    desynchronized: true,
    antialias: false,
    depth: false,
    failIfMajorPerformanceCaveat: false,
    powerPreference: "high-performance",
    preserveDrawingBuffer: false,
    stencil: false
  });
  const glFrameBuffer = gl.createFramebuffer();
  let bioHtmlVisible = null;
  let _foundHtmlCount = -2;
  function resetHtmlState() {
    bioHtmlVisible = null;
    _foundHtmlCount = -2;
  }
  function updateBio() {
    if (_foundHtmlCount !== GAME_STATE._foundCount) {
      const floppiesCount = GAME_STATE._floppies.length;
      _foundHtmlCount = GAME_STATE._foundCount;
      if (_foundHtmlCount >= floppiesCount) {
        foundTextElement.innerHTML = '<h2 style="text-align:center"><b>\u{1F3C6}</b><br/>Congratulations!<br/>You found all the joiners!</h2>';
      } else {
        foundTextElement.innerHTML = `${_foundHtmlCount}/${floppiesCount}&nbsp;<b>\u{1F4BE}</b>`;
      }
    }
    const bioVisible = !mainMenuVisible && GAME_STATE._bioIndex >= 0;
    if (bioHtmlVisible !== bioVisible) {
      bioHtmlVisible = bioVisible;
      if (bioHtmlVisible) {
        body.classList.add("bio");
        bioHtmlContentDiv.innerHTML = bios_sp_html;
      } else {
        body.classList.remove("bio");
      }
    }
  }
  const GL_TRIANGLES = 4;
  const GL_NICEST = 4354;
  const GL_GENERATE_MIPMAP_HINT = 33170;
  const GL_UNSIGNED_BYTE = 5121;
  const GL_RGBA = 6408;
  const GL_FRAGMENT_SHADER = 35632;
  const GL_VERTEX_SHADER = 35633;
  const GL_NEAREST = 9728;
  const GL_LINEAR = 9729;
  const GL_LINEAR_MIPMAP_LINEAR = 9987;
  const GL_TEXTURE_MAG_FILTER = 10240;
  const GL_TEXTURE_MIN_FILTER = 10241;
  const GL_TEXTURE_WRAP_S = 10242;
  const GL_TEXTURE_WRAP_T = 10243;
  const GL_TEXTURE_2D = 3553;
  const GL_TEXTURE0 = 33984;
  const GL_TEXTURE1 = 33985;
  const GL_TEXTURE2 = 33986;
  const GL_TEXTURE5 = 33989;
  const GL_REPEAT = 10497;
  const GL_CLAMP_TO_EDGE = 33071;
  const GL_FRAMEBUFFER = 36160;
  const GL_COLOR_ATTACHMENT0 = 36064;
  const glSetTextureSampling = (wrap = GL_REPEAT, minFilter = GL_LINEAR, magFilter = minFilter) => {
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap);
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap);
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
  };
  const code = "#version 300 es\nprecision mediump int;uniform vec2 iR;out vec2 FC;void main(){vec2 a=vec2(float((gl_VertexID&1)<<2),float((gl_VertexID&2)<<1));gl_Position=vec4(a-1.,0.,1.);FC=a*iR*.5;}";
  const code$1 = "#version 300 es\nprecision highp float;in vec2 FC;uniform vec2 iR;uniform vec3 iP;uniform vec4 iD;uniform vec4 iS;uniform mat3 iM;uniform int iF0;out vec4 oC;uniform highp sampler2D tN;uniform highp sampler2D tH;uniform highp sampler2D tP;float a;float b(float a){return clamp(a,0.,1.);}float c(float a,float b,float c){float d=max(c-abs(a-b),0.)/c;return min(a,b)-d*d*c/4.;}vec4 d(float a){vec4 c=b(a)*vec4(.999998,254.99948,65024.867,160581056);c=fract(c);c-=c.yzww*vec4(.003921569,.003921569,.003921569,0);return c;}float e(vec4 a){return dot(a,vec4(1,.003921569,1.53787e-5,6.2273724e-9));}vec3 f(vec2 a){vec4 b=texelFetch(tN,ivec2(floor(a))&511,0);float c=b.y-b.x,d=b.z-b.x,e=b.w-c-b.z;vec2 f=fract(a),g=f*f,h=g*(3.-2.*f);return vec3(b.x+c*h.x+d*h.y+e*h.x*h.y,30.*g*(f*(f-2.)+1.)*(vec2(c,d)+e*h.yx));}int g=0;float h=150.;void i(int b,float c){if(c<a&&c!=h){g=b;h=c;}}float j(vec3 a,vec3 b){vec3 c=abs(a)-b;return min(max(c.x,max(c.y,c.z)),0.)+length(max(c,0.));}float k(vec3 a,float b){vec3 c=abs(a)-b;return min(max(c.x,max(c.y,c.z)),0.)+length(max(c,0.));}float l(vec3 a,float b,float c){float d=length(a.xy)-b;return max(d,abs(a.z)-c);}float m(vec3 a,float b,float c){float d=length(a.xz)-b;return max(d,abs(a.y)-c);}float n(float a,float b,float c,float d){float e=b*.5,f=floor((a+e)/b),g=mod(a+e,b)-e;return f>d?g+b*(f-d):f<c?g+b*(f-c):g;}mat2 o(float a){float b=cos(a),c=sin(a);return mat2(b,c,-c,b);}vec3 p(vec3 a,float b){a.xz*=o(b);return a;}float q(float a,float b){return abs(a)-b;}float r(vec3 a){float b=j(a-vec3(.056,0,0),vec3(.035,.006,.05)),c=j(a,vec3(.09,.005,.0937));if(c<b){i(2,c);return c;}i(1,b);return b;}float s(vec3 a){vec3 b=abs(vec3(a.x,a.y+3.,a.z))-vec3(60,0,39);if(b.x<0.&&b.z<0.){float c=e(textureLod(tH,a.xz/vec2(120,78)+.5,0.));b.y-=c*17.8;}return min(b.y,0.)+length(max(b,0.));}float t(vec3 a){vec3 b=p(a,0.),c=b-vec3(0,-.9,-15.5);c.yz*=o(-.5);float d=min(j(b,vec3(2,.35,14)),j(c,vec3(2,.35,1.9)));b.x=n(b.x-2.,4.,-1.1,.1);float e=l(b-vec3(0,1.75,0),.11,14.);vec3 f=b-vec3(0,-1,0);f.z=n(f.z,3.5,-4.,4.);float g=m(f,.2,3.);i(1,e);i(-1,g);return min(g,min(e,d));}float u(vec3 a){float b=m(a,.55,.8);i(4,b);return b;}float v(vec3 a){float b=k(a,.8);i(-1,b);return b;}float w(vec3 a){vec3 b=p(a.xyz-vec3(-39,1.4,1),-.1);float c=length(b)-8.;if(c>5.)return c;b.y-=2.;float d=j(b-vec3(-2.7,-1.2,1.2),vec3(.35,.6,.7)),e=max(q(j(b,vec3(4,2,2)),.23),-min(l(b-vec3(0,.2,0),.8,100.),j(b-vec3(5.5,-.37,0),vec3(3,1.8,1.5))));b.x=n(b.x,.3,-10.,10.);b.z=abs(b.z);float f=l(b-vec3(0,2,.5),.01,1.);i(1,f);i(-1,d);float g=min(f,min(e,d)),h=150.;if(h<g){i(2,h);return h;}return g;}float x(vec3 a){float b=max(q(l(a,2.5,3.),.1),-l(a,2.,6.));i(1,b);float c=m(a-vec3(-1.5,-.9,-1.3),.5,.6);i(3,c);return min(b,c);}float y(vec3 a){float b=t(a-vec3(20,1.6,40));b=min(b,min(u(a-vec3(18,1.15,22)),min(u(a-vec3(16.8,1.21,22.1)),u(a-vec3(17.4,1.17,21)))));b=min(b,v(p(a-vec3(26,1.15,22),1.2)));b=min(b,u(a-vec3(36,4.55,-13)));b=min(b,min(v(p(a-vec3(47,1.37,2),-.3)),v(a-vec3(47.5,1.6,.14))));b=min(b,w(a));b=min(b,min(u(a-vec3(-48,1.83,14)),u(a-vec3(-48.8,1.83,13.2))));b=min(b,min(j(a-vec3(-7.5,6.5,-17),vec3(2,1,2)),j(a-vec3(-7.5,6,-17),vec3(4,.3,1))));b=min(b,x(a-vec3(9,12.5,2)));b=min(b,m(a-vec3(2.3,13.6,-1),2.,1.));b=min(b,m(a-vec3(2.3,13.7,-1),.5,4.));b=min(b,m(a-vec3(2.3,15.7,-1),1.,.1));b=min(b,m(a-vec3(2.3,16.5,-1),.75,.1));float c=150.;if((iF0&1)!=0)c=min(c,r(a-vec3(18.33,1.9562,22.34)));if((iF0&2)!=0)c=min(c,r(a-vec3(25.7,1.9562,22.5)));if((iF0&4)!=0)c=min(c,r(a-vec3(36,5.361,-12.6)));if((iF0&8)!=0)c=min(c,r(a-vec3(47.1,2.407,.14)));if((iF0&16)!=0)c=min(c,r(a-vec3(-41.5,2.805,2.1)));if((iF0&32)!=0)c=min(c,r(a-vec3(-47.8,2.64,13.6)));if((iF0&64)!=0)c=min(c,r(p(a-vec3(-11.3,6.308,-16.1),.5)));if((iF0&128)!=0)c=min(c,r(a-vec3(7.7,12.2,.44)));if((iF0&256)!=0)c=min(c,r(a-vec3(1.5,15.805,-.95)));if(c<b)return c;i(0,b);return b;}int z=0;float A(vec3 b){float c=s(b);if(c>a){float a=y(b);if(c>=a){z=2;return a;}}z=1;return c;}vec3 B(vec3 a){return normalize(vec3(y(a+vec3(.001,0,0)),y(a+vec3(0,.001,0)),y(a+vec3(0,0,.001)))-y(a));}vec3 C(vec3 a,float b){vec2 c=vec2(mix(.03,.001,min(b/120.,1.)),0);return normalize(vec3(s(a+c.xyy),s(a+c.yxy),s(a+c.yyx))-s(a));}float D(vec3 b,vec3 c,float d,float e){float f=d;for(int g=0;;g++){vec3 h=b+c*e;a=d*max(e,1.);if(h.y<=-2.9995||e>=150.){float a=(-3.-b.y)/c.y;if(a>=0.&&a<500.){z=1;return a;}break;}if(h.y>45.)break;float i=A(h);if(i<0.){e-=f;i=f/2.;}e+=i;if(i<=a||g>=100)return e;f=i;}z=0;return 500.;}float E(vec3 b,float c,vec3 d,float e){float f=clamp(c*.005,.01,.1);b=b+d*f;float g=iS.w-a*2.;for(float h=1.;h<50.;h++){vec3 c=b+iS.xyz*f;if(f>=80.||c.y>45.||c.y<g||length(b)>=150.)break;float d=y(c),i=max(a,.01*min(1.,f)+h*2e-4);if(d<=i)return 0.;e=min(e,85.*d/f);if(e<.078)return 0.;f+=d+a;}return e;}float F(vec3 a,vec3 b){float c=(iS.w-a.y)/b.y;return min(c>=0.?c:500.,500.);}vec3 G(vec2 a){vec3 b=vec3(0);float c=0.,d=1.,e=0.,g=1.-length(iP.xz-a)/500.,h=5.*g*g;for(float i=0.;i<h;++i){a+=iD.w*.5;e*=-.75;vec3 g=f(a+sin(a.yx*.5+iD.w*.5)*.5);b+=g*d;a+=g.yz*.43;a*=2.;c+=d;d*=.75;}return b/c;}vec3 H(vec3 a,float c,vec3 d){float e=min(c/500.,1.),f=b(pow(e,3.5)+1.-exp(-c*.005)),g=max(dot(d,iS.xyz),0.);vec3 h=mix(vec3(.4,.8,1),vec3(1.065,.95,.85),pow(g,10.));return mix(a,h,f);}vec3 I(vec3 a,vec3 c){vec4 d=texelFetch(tP,ivec2(FC*256./iR),0);float e=uintBitsToFloat(uint(d.x*255.)<<24|uint(d.y*255.)<<16|uint(d.z*255.)<<8|uint(d.z*255.)),f=D(a,c,.001,e),h=F(a,c);vec3 i,j=vec3(0,1,0);float k=f;vec3 l=a+c*f;bool m=h<500.&&h<f;vec3 n;float o=0.;if(m){o=mix(.2,1.,b((f-h)/3.));vec3 d=a+c*h,e=mix(vec3(0),G(d.xz*(.7-iS.w*.02))*(1.-length(d)/450.),o);j=normalize(vec3(e.y,1.,e.x));h-=abs(e.z)*o*.6;k=h;n=mix(vec3(.25,.52,.73),vec3(.15,.62,.83),b(abs(e.z)-o));}int p=z,q=g;if(z==0)i=vec3(.4,.8,1);else{vec3 a;if(l.y<=-2.9995){a=vec3(0,1,0);i=vec3(1);}else{i=vec3(.8);switch(p){case 1:a=C(l,f);i=mix(vec3(.93,.8,.64),mix(vec3(.69+texture(tN,l.xz*1e-4).x,.67,.65),vec3(.38,.52,.23),dot(a,vec3(0,1,0))),b(l.y*.5-1.))+texture(tN,l.xz*.15).x*.1+texture(tN,l.xz*.01).y*.1;break;case 2:a=B(l);switch(q){case 1:i=vec3(1);break;case 2:i=vec3(1,0,0);break;case 3:i=vec3(.5,0,0);break;case 4:i=vec3(1,1,.8);break;case-1:i=vec3(.64000005,.48000002,.32000002);break;default:vec4 b=texture(tN,l.xy*.35)*a.z+texture(tN,l.yz*.35)*a.x+texture(tN,l.xz*.35)*a.y-.5;i+=.125*(b.x-b.y+b.z-b.w);break;}}j=normalize(mix(a,j,o));}}float r=m||p==2&&q>0?pow(b(dot(iS.xyz,reflect(c,j))),50.):0.,s=b(dot(iS.xyz,j)),t=b(dot(iS.xyz*vec3(-1,1,-1),j)),u=s+t*.15;if(p==1)u=pow(u*mix(.9,1.02,s*s),1.+s*.6);u=mix(u,s,o);float v=1.;if(z!=0)v=E(a+c*k,k,j,1.);i=mix(i,n,o);i=(i*vec3(1.065,.95,.85)*u+r)*mix(.38+(1.-u)*.2,1.,v);return H(i,k,c);}void main_c(){vec3 a=vec3(0,0,1);a.xz*=o(FC.x*.049087387+3.1415927);oC=d(.2-A(vec3(iP.x,iP.y+(FC.y/64.-1.)-.8,iP.z)+normalize(a)*.15));}void main_p(){vec2 b=FC/128.-1.;vec3 c=normalize(iM*vec3(b.x*-1.5,b.y,2.4142134));float d=D(iP,c,.0056640627,.15);uint e=floatBitsToUint(d>=150.?150.:d-a);oC=vec4(float(e>>24&255u)/255.,float(e>>16&255u)/255.,float(e>>8&255u)/255.,float(e&255u)/255.);}void main_m(){vec2 a=FC/(iR*.5)-1.;vec3 b=normalize(iM*vec3(a.x*-1.5,a.y,2.4142134));oC=vec4(I(iP,b),1);}float J(vec2 a,float c,float d,float e,float f){vec2 g=a-vec2(c,d);return b(1.-smoothstep(e-e*f,e,dot(g,g)*4.));}void main_h(){vec2 a=FC/(iR*.5)-1.,e=vec2(1.3,1),g=vec2(0);float h=0.,i=1.,j=1.,k=0.,l=1.;while(l<11.){vec3 b=f(21.1+a*e*o(l++*2.5));g+=b.yz;h+=j*(1.-b.x)/(1.+dot(g,g));i+=j*(.5-b.x);k+=j;j*=.5;e*=1.8;}h/=k;i*=.5;float m=length(a*(1.2-i+h))*b(i+.56-.5*h*a.x*(1.-a.y*.5)),n=J(a,-.45,-.52,1.,2.3)+J(a,-.6,-.1,1.,3.3)+J(a,.5,-.7,1.,5.)+J(a,.6,.53,h*2.,i*5.);m=b(1.-c(m,1.-mix(0.,h*2.,n),.05+i*.5));vec2 p=1.-abs(a)+h*.04;m=c(m,c(p.x,p.y,.3)*2.,.1);oC=d(c(h,m,.01)*1.33-.045);}";
  const loadShaderFunction = (mainFunction) => {
    const program = gl.createProgram();
    const loadShaderCode = (type, sourceCode) => {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, sourceCode);
      gl.compileShader(shader);
      gl.attachShader(program, shader);
      return shader;
    };
    const vertexShader = loadShaderCode(GL_VERTEX_SHADER, code);
    const fragmentShader = loadShaderCode(GL_FRAGMENT_SHADER, code$1.replace(`main_${mainFunction}`, "main"));
    gl.linkProgram(program);
    gl.useProgram(program);
    const iNoise = gl.getUniformLocation(program, "tN");
    const iHeightmap = gl.getUniformLocation(program, "tH");
    const iPrerendered = gl.getUniformLocation(program, "tP");
    const iResolution = gl.getUniformLocation(program, "iR");
    const iCameraMat3 = gl.getUniformLocation(program, "iM");
    const iSunDirection = gl.getUniformLocation(program, "iS");
    const iP = gl.getUniformLocation(program, "iP");
    const iD = gl.getUniformLocation(program, "iD");
    const iF0 = gl.getUniformLocation(program, "iF0");
    [iNoise, iHeightmap, iPrerendered].map((t, i) => gl.uniform1i(t, i));
    const useShader = (width, height, isCollider) => {
      gl.viewport(0, 0, width, height);
      gl.useProgram(program);
      gl.uniform2f(iResolution, width, height);
      const waterLevel = sin(gameTime * 2 + 3) * 0.2;
      vec3Normalize(vec3Set(vec3Temp0, 0.4 + cos(gameTime * 0.02) * 0.1, 0.44 + sin(gameTime * 0.02) * 0.1 - 0.05, -0.38));
      gl.uniform4f(iSunDirection, vec3Temp0.x, vec3Temp0.y, vec3Temp0.z, waterLevel);
      gl.uniform3f(iP, cameraPos.x, cameraPos.y + (isCollider ? 0 : headBob), cameraPos.z);
      gl.uniform4f(iD, cameraDir.x, cameraDir.y, cameraDir.z, gameTime);
      gl.uniformMatrix3fv(iCameraMat3, false, cameraMat3);
      let floppiesMask = 0;
      const floppies = GAME_STATE._floppies;
      for (let i = 0; i < floppies.length; ++i) {
        floppiesMask |= floppies[i]._visible ? 1 << i : 0;
      }
      gl.uniform1i(iF0, floppiesMask);
    };
    return useShader;
  };
  let mainShader;
  let collisionShader;
  let prerenderedShader;
  const loadMainShader = () => {
    mainShader = loadShaderFunction("m");
    collisionShader = loadShaderFunction("c");
    prerenderedShader = loadShaderFunction("p");
  };
  const HEIGHTMAP_TETURE_SIZE = 4096;
  const heightmapTexture = gl.createTexture();
  const buildHeightmapTexture = () => {
    gl.activeTexture(GL_TEXTURE1);
    gl.bindTexture(GL_TEXTURE_2D, heightmapTexture);
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, HEIGHTMAP_TETURE_SIZE, HEIGHTMAP_TETURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, null);
    gl.bindFramebuffer(GL_FRAMEBUFFER, glFrameBuffer);
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, heightmapTexture, 0);
    loadShaderFunction("h")(HEIGHTMAP_TETURE_SIZE, HEIGHTMAP_TETURE_SIZE);
    gl.drawArrays(GL_TRIANGLES, 0, 3);
    gl.generateMipmap(GL_TEXTURE_2D);
    glSetTextureSampling(GL_CLAMP_TO_EDGE, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
    gl.bindFramebuffer(GL_FRAMEBUFFER, null);
  };
  const NOISE_TEXTURE_SIZE = 512;
  const noiseTexture = gl.createTexture();
  const buildNoiseTexture = () => {
    gl.activeTexture(GL_TEXTURE0);
    gl.bindTexture(GL_TEXTURE_2D, noiseTexture);
    const data2 = new Uint8Array(NOISE_TEXTURE_SIZE * NOISE_TEXTURE_SIZE * 4);
    let xoshiroA = 345;
    let xoshiroB = 737;
    let xoshiroC = 1082;
    let xoshiroD = 254265;
    for (let y = 0; y < NOISE_TEXTURE_SIZE; ++y) {
      const ay = y * (NOISE_TEXTURE_SIZE * 4);
      const by = ((y - 1) % NOISE_TEXTURE_SIZE + NOISE_TEXTURE_SIZE) % NOISE_TEXTURE_SIZE * (NOISE_TEXTURE_SIZE * 4);
      for (let x = 0; x < NOISE_TEXTURE_SIZE; ++x) {
        const t = xoshiroB << 9;
        let xoshiro = xoshiroA * 5;
        xoshiro = (xoshiro << 7 | xoshiro >>> 25) * 9;
        xoshiroC ^= xoshiroA;
        xoshiroD ^= xoshiroB;
        xoshiroB ^= xoshiroC;
        xoshiroA ^= xoshiroD;
        xoshiroC ^= t;
        xoshiroD = xoshiroD << 11 | xoshiroD >>> 21;
        xoshiro &= 255;
        const ax = x * 4;
        const bx = ((x - 1) % NOISE_TEXTURE_SIZE + NOISE_TEXTURE_SIZE) % NOISE_TEXTURE_SIZE * 4;
        data2[ax + ay] = xoshiro;
        data2[bx + ay + 1] = xoshiro;
        data2[ax + by + 2] = xoshiro;
        data2[bx + by + 3] = xoshiro;
      }
    }
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, data2);
    gl.hint(GL_GENERATE_MIPMAP_HINT, GL_NICEST);
    gl.generateMipmap(GL_TEXTURE_2D);
    glSetTextureSampling(GL_REPEAT, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
  };
  const CAMERA_MAX_DISTANCE_FROM_CENTER = 100;
  const COLLIDER_SIZE = 128;
  const colliderTexture = gl.createTexture();
  const colliderFrameBuffer = gl.createFramebuffer();
  const colliderBuffer = new Uint8Array(COLLIDER_SIZE * COLLIDER_SIZE * 4);
  const readDist = (x, y) => {
    const bufIdx = y * COLLIDER_SIZE * 4 + x * 4;
    return unpackFloatBytes4(colliderBuffer[bufIdx], colliderBuffer[bufIdx + 1], colliderBuffer[bufIdx + 2], colliderBuffer[bufIdx + 3]);
  };
  const getAngleFromIdx = (x) => -(PI * (x - 64) / 64) - PI / 2;
  const initCollider = () => {
    gl.activeTexture(GL_TEXTURE5);
    gl.bindTexture(GL_TEXTURE_2D, colliderTexture);
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, COLLIDER_SIZE, COLLIDER_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, null);
    gl.bindFramebuffer(GL_FRAMEBUFFER, colliderFrameBuffer);
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colliderTexture, 0);
  };
  const updateCollider = () => {
    collisionShader(COLLIDER_SIZE, COLLIDER_SIZE, true);
    gl.bindFramebuffer(GL_FRAMEBUFFER, colliderFrameBuffer);
    gl.drawArrays(GL_TRIANGLES, 0, 3);
    gl.readPixels(0, 0, COLLIDER_SIZE, COLLIDER_SIZE, GL_RGBA, GL_UNSIGNED_BYTE, colliderBuffer);
    gl.bindFramebuffer(GL_FRAMEBUFFER, null);
    let totalY = 0;
    for (let x = 0; x < 128; x++) {
      let maxY = -99;
      for (let y = 0; y < 32; y++) {
        maxY = max(readDist(x, y), maxY);
      }
      totalY += maxY;
    }
    const ddy = totalY / 128 - 0.2;
    let ddx = 0;
    let ddz = 0;
    for (let y = 32; y < 96; ++y) {
      for (let x1 = 0; x1 < 64; ++x1) {
        const x2 = x1 + 64;
        const dist1 = readDist(x1, y);
        const dist2 = readDist(x2, y);
        const angle1 = getAngleFromIdx(x1);
        const angle2 = getAngleFromIdx(x2);
        const dx = cos(angle1) * dist1 + cos(angle2) * dist2;
        const dz = sin(angle1) * dist1 + sin(angle2) * dist2;
        if (abs(dx) > abs(ddx)) {
          ddx = dx;
        }
        if (abs(dz) > abs(ddz)) {
          ddz = dz;
        }
      }
    }
    cameraPos.x += ddx;
    cameraPos.y = max(cameraPos.y + ddy, 0.9);
    cameraPos.z += ddz;
    const distanceFromCenter = vec3Length(cameraPos);
    if (distanceFromCenter >= CAMERA_MAX_DISTANCE_FROM_CENTER) {
      cameraPos.x *= CAMERA_MAX_DISTANCE_FROM_CENTER / distanceFromCenter;
      cameraPos.z *= CAMERA_MAX_DISTANCE_FROM_CENTER / distanceFromCenter;
    }
  };
  const PRERENDERED_TEXTURE_SIZE = 256;
  const prerenderedTexture = gl.createTexture();
  const initPrerenderedTexture = () => {
    gl.activeTexture(GL_TEXTURE2);
    gl.bindTexture(GL_TEXTURE_2D, prerenderedTexture);
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, PRERENDERED_TEXTURE_SIZE, PRERENDERED_TEXTURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, null);
    glSetTextureSampling(GL_CLAMP_TO_EDGE, GL_NEAREST);
    gl.bindFramebuffer(GL_FRAMEBUFFER, glFrameBuffer);
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, prerenderedTexture, 0);
    gl.bindFramebuffer(GL_FRAMEBUFFER, null);
  };
  const data = [GAME_STATE, ANIMATIONS, cameraPos, cameraEuler];
  function deepMerge(original, item) {
    for (const key in item) {
      if (typeof item[key] === "object") {
        deepMerge(original[key], item[key]);
      } else {
        original[key] = item[key];
      }
    }
  }
  const LOCAL_STORAGE_KEY = "joiners30-12-20";
  const SAVE_GAME = () => {
    if (gameStarted) {
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
      setText("Saved", 2);
      startOrResumeClick(false);
      loadGameButton.className = "";
    }
  };
  const getDataFromLocalStorage = () => localStorage.getItem(LOCAL_STORAGE_KEY);
  const LOAD_GAME = () => {
    const savedGame = getDataFromLocalStorage();
    if (savedGame) {
      clearTexts();
      startOrResumeClick(false);
      deepMerge(data, JSON.parse(savedGame));
      setText("Game loaded", 2);
    }
  };
  saveGameButton.onclick = SAVE_GAME;
  loadGameButton.onclick = LOAD_GAME;
  loadGameButton.className = getDataFromLocalStorage() ? "" : "X";
  setTimeout(() => {
    buildNoiseTexture();
    buildHeightmapTexture();
    initPrerenderedTexture();
    initCollider();
    loadMainShader();
    showMainMenu();
    const animationFrame = debug_trycatch_wrap((browserTimeInMilliseconds) => {
      requestAnimationFrame(animationFrame);
      if (!updateTime(browserTimeInMilliseconds, mainMenuVisible)) {
        return;
      }
      updateCamera();
      if (!mainMenuVisible) {
        if (!GAME_STATE._gameEnded && GAME_STATE._bioIndex < 0) {
          updateCollider();
        }
        updateAnimations();
        updateGameObjects();
        updateText();
      }
      prerenderedShader(PRERENDERED_TEXTURE_SIZE, PRERENDERED_TEXTURE_SIZE);
      gl.bindFramebuffer(GL_FRAMEBUFFER, glFrameBuffer);
      gl.drawArrays(GL_TRIANGLES, 0, 3);
      gl.bindFramebuffer(GL_FRAMEBUFFER, null);
      mainShader(renderWidth, renderHeight);
      gl.drawArrays(GL_TRIANGLES, 0, 3);
      updateBio();
    });
    requestAnimationFrame(animationFrame);
  }, 99);
})();}
__js_load_modules__();</script></body></html>