<html><head>
    <title>Find all the joiners!</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>*{
  user-select:none;
}
#bio{
  position:absolute;
  top:0;
  left:0;
  bottom:0;
  right:0;
  display:none;
  background-color:rgba(0, 0, 0, 0.9);
  pointer-events:none;
  overflow:scroll;
  padding:18px;
}
.bio #bio{
  display:block;
}
html,
body{
  margin:0;
  padding:0;
}
body,
#M{
  align-items:center;
  display:flex;
  justify-content:center;
  height:100%;
  text-shadow:0px 0px 8px #000, -1px -1px 3px #000, 1px 1px 3px #000;
  background:#000;
  color:#fca;
  text-align:center;
  font-family:Papyrus, Gabriola, 'Times New Roman', Times, serif;
}
#M{
  position:relative;
  letter-spacing:0.01em;
}
input{
  width:1.2rem;
  height:1.2rem;
  vertical-align:middle;
}
#V{
  width:15em;
}
#N{
  position:absolute;
  top:0;
}
#N{
  display:none;
  width:100%;
  height:100%;
  backdrop-filter:blur(15px) contrast(200%) brightness(35%);
}
b{
  cursor:pointer;
}
b:hover{
  text-decoration:underline;
}
.X{
  opacity:0.5;
  cursor:no-drop;
}
.X:hover{
  text-decoration:none;
}
#T{
  padding:2px;
  bottom:0;
  position:absolute;
}
h1,
h3{
  margin:0.2em;
}
small{
  display:block;
  margin:0.55em;
}
label{
  margin:0.4em;
}
@-moz-document url-prefix(){
.N #C{
    filter:blur(15px) contrast(190%) brightness(50%);
}
}
#found-text{
  position:absolute;
  top:0;
  left:0;
  right:0;
}
.N #T,
.N #bio,
.N #found-text,
.bio #found-text,
.bio #T{
  display:none;
}
.N #N{
  display:block;
}
a,
a:visited,
a:active{
  opacity:0.7;
  font-size:0.6em;
  color:#fca;
}
a:hover{
  opacity:1;
}
</style></head>

  <body class="L">
    <div id="M">
      <canvas id="C"></canvas>
      <div id="found-text"></div>
      <div id="T">
        <h1>Loading...</h1>
      </div>
      <div id="N">
        <h1>Find all the joiners!</h1>
        <h3><b id="R">New Game</b></h3>
        <h3><b id="S" class="X">Save Game</b></h3>
        <h3><b id="L">Load Game</b></h3>
        <small>
          <label><input type="checkbox" id="Y"> Invert Y </label>
          <label> <input type="checkbox" id="Q" checked> High quality </label>
          <label> <input type="checkbox" id="H" checked> Head Bob </label><br>
          <label>Mouse sensitivity <input type="range" id="V" value="28"></label>
          <br>
          <br>
          Shift: run<br>
          W,A,S,D/Arrows: move, strafe<br>
          Mouse: look around<br>
          E,Space: interact<br>
          Esc,M: menu
        </small>
      </div>
    </div>
    <div id="bio">
      <div id="bioc"></div>
      <footer>[Press E or Space to continue]</footer>
    </div>
  
  

<script>function __js_load_modules__(){(function() {
  const {
    abs,
    acos,
    acosh,
    asin,
    asinh,
    atan,
    atanh,
    atan2,
    ceil,
    cbrt,
    expm1,
    clz32,
    cos,
    cosh,
    exp,
    floor,
    fround,
    hypot,
    imul,
    log,
    log1p,
    log2,
    log10,
    max,
    min,
    random,
    round,
    sign,
    sin,
    sinh,
    sqrt,
    tan,
    tanh,
    trunc,
    E,
    LN10,
    LN2,
    LOG10E,
    LOG2E,
    PI,
    SQRT1_2,
    SQRT2
  } = Math;
  const TWO_PI = PI * 2;
  const DEG_TO_RAD = PI / 180;
  const lerp = (from, to, t) => from + t * (to - from);
  const clamp = (value, minimum, maximum) => min(max(value, minimum), maximum);
  const wrapAngleInRadians = (angle) => angle - TWO_PI * floor((angle + PI) / TWO_PI);
  const scalarAdd = (a, b) => a + b;
  const scalarSubtract = (a, b) => a - b;
  const scalarMultiply = (a, b) => a * b;
  const scalarDivide = (a, b) => a / b;
  const unpackFloatBytes4 = (r, g, b, a) => {
    return r / 255 + g / 65025 + b / 16581375 + a / 40948250625;
  };
  const {
    assign: objectAssign,
    getOwnPropertyDescriptor: objectGetOwnPropertyDescriptor,
    getOwnPropertyDescriptors: objectGetOwnPropertyDescriptors,
    getOwnPropertyNames: objectGetOwnPropertyNames,
    getOwnPropertySymbols: objectGetOwnPropertySymbols,
    is: objectIs,
    preventExtensions: objectPreventExtensions,
    seal: objectSeal,
    create: objectCreate,
    defineProperties: objectDefineProperties,
    defineProperty: objectDefineProperty,
    freeze: objectFreeze,
    getPrototypeOf: objectGetPrototypeOf,
    setPrototypeOf: objectSetPrototypeOf,
    isExtensible: objectIsExtensible,
    isFrozen: objectIsFrozen,
    isSealed: objectIsSealed,
    keys: objectKeys,
    entries: objectEntries,
    fromEntries: objectFromEntries,
    values: objectValues
  } = Object;
  const debug_trycatch_wrap = (fn, _info) => fn;
  const KEY_FORWARD = 1;
  const KEY_BACKWARD = 2;
  const KEY_STRAFE_LEFT = 3;
  const KEY_STRAFE_RIGHT = 4;
  const KEY_RUN = 5;
  const KEY_ACTION = 6;
  const KEY_MAIN_MENU = 8;
  const PressedKeys = [];
  const KeyFunctions = {};
  const _keyMap = {
    w: KEY_FORWARD,
    W: KEY_FORWARD,
    z: KEY_FORWARD,
    Z: KEY_FORWARD,
    ArrowUp: KEY_FORWARD,
    s: KEY_BACKWARD,
    S: KEY_BACKWARD,
    ArrowDown: KEY_BACKWARD,
    a: KEY_STRAFE_LEFT,
    A: KEY_STRAFE_LEFT,
    q: KEY_STRAFE_LEFT,
    Q: KEY_STRAFE_LEFT,
    ArrowLeft: KEY_STRAFE_LEFT,
    d: KEY_STRAFE_RIGHT,
    D: KEY_STRAFE_RIGHT,
    ArrowRight: KEY_STRAFE_RIGHT,
    Shift: KEY_RUN,
    e: KEY_ACTION,
    E: KEY_ACTION,
    " ": KEY_ACTION,
    Escape: KEY_MAIN_MENU,
    M: KEY_MAIN_MENU,
    m: KEY_MAIN_MENU
  };
  const _setKeyPressed = (e, value) => {
    if (!e.keyCode || e.metaKey || !document.activeElement || mainMenuVisible) {
      PressedKeys.length = 0;
    } else {
      const keyId = _keyMap[e.key] | 0;
      if (value && KeyFunctions[keyId]) {
        KeyFunctions[keyId](e.repeat);
      }
      PressedKeys[keyId] = value;
    }
  };
  onkeydown = (ev) => _setKeyPressed(ev, true);
  onkeyup = (ev) => _setKeyPressed(ev, false);
  const vec3New = (x, y, z) => ({x, y, z});
  const vec3NewValue = (value = 0) => ({x: value, y: value, z: value});
  const vec3Temp0 = vec3NewValue();
  const vec3Temp1 = vec3NewValue();
  const VEC3_UNIT_Y = vec3New(0, 1, 0);
  const vec3Set = (out, x, y, z) => {
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
  };
  const vec3SetEachVecVec = (out, {x, y, z}, b, fn) => vec3Set(out, fn(x, b.x), fn(y, b.y), fn(z, b.z));
  const vec3SetEachVecScalar = (out, {x, y, z}, b, fn) => vec3Set(out, fn(x, b), fn(y, b), fn(z, b));
  const vec3Dot = ({x, y, z}, b) => x * b.x + y * b.y + z * b.z;
  const vec3LengthSquared = ({x, y, z}) => x ** 2 + y ** 2 + z ** 2;
  const vec3Length = (a) => sqrt(vec3LengthSquared(a));
  const vec3DistanceSquared = ({x, y, z}, b) => (b.x - x) ** 2 + (b.y - y) ** 2 + (b.z - z) ** 2;
  const vec3Distance = (a, b) => sqrt(vec3DistanceSquared(a, b));
  const vec3Add = (out, a, b = out) => vec3SetEachVecVec(out, a, b, scalarAdd);
  const vec3Subtract = (out, a, b) => vec3SetEachVecVec(out, a, b, scalarSubtract);
  const vec3ScalarMultiply = (out, b, a = out) => vec3SetEachVecScalar(out, a, b, scalarMultiply);
  const vec3DivideScalar = (out, a, b) => vec3SetEachVecScalar(out, a, b, scalarDivide);
  const vec3Normalize = (out, a = out) => vec3DivideScalar(out, a, vec3Length(a));
  const vec3Direction = (out, a, b) => vec3Normalize(vec3Subtract(out, b, a));
  const vec3Cross = (out, {x, y, z}, {x: bx, y: by, z: bz}) => vec3Set(out, y * bz - z * by, z * bx - x * bz, x * by - y * bx);
  const vec2New = (x, y) => ({x, y});
  const vec2Set = (out, x, y) => {
    out.x = x;
    out.y = y;
    return out;
  };
  const typedArraySet = (array, ...values) => array.set(values);
  const MAX_GAME_TIME_DELTA_PER_FRAME = 0.033;
  let gameTime = 0;
  let gameTimeDelta = MAX_GAME_TIME_DELTA_PER_FRAME;
  let globalTime = 0;
  let renderDuringPausedGameTime = 0;
  const updateTime = (browserTimeInMilliseconds, paused) => {
    const newGlobalTime = browserTimeInMilliseconds / 1e3;
    const globalTimeDiff = newGlobalTime - globalTime;
    globalTime = newGlobalTime;
    if (paused) {
      gameTimeDelta = 0;
      if (newGlobalTime - renderDuringPausedGameTime >= 0.2) {
        renderDuringPausedGameTime = newGlobalTime;
        return true;
      }
      return false;
    }
    gameTimeDelta = min(globalTimeDiff, MAX_GAME_TIME_DELTA_PER_FRAME);
    gameTime += gameTimeDelta;
    return gameTimeDelta > 0;
  };
  const ANIMATIONS = {};
  const ANIMATIONS_LIST = objectValues(ANIMATIONS);
  let RUMBLING = false;
  function updateAnimations() {
    RUMBLING = false;
    for (const anim of ANIMATIONS_LIST) {
      if (anim._running) {
        if (anim._rumble) {
          RUMBLING = anim._rumble(anim._value);
        }
        anim._value += anim._speed * gameTimeDelta * anim._running;
        if (anim._value > anim._max || anim._value < anim._initial) {
          anim._value = anim._running > 0 ? anim._max : anim._initial;
          if (anim._onComplete) {
            anim._onComplete();
          }
          anim._running = 0;
        }
      }
    }
  }
  const EMPTY = {_text: "", _timeout: -1};
  let currentText = EMPTY;
  const textQueue = [];
  const clearTexts = () => {
    textQueue.length = 0;
    currentText = EMPTY;
    gameTextElement.innerHTML = "";
  };
  const setText = (text, timeout = -1) => {
    const textObject = text || timeout > 0 ? {_text: text, _timeout: timeout} : EMPTY;
    if (textQueue[0]) {
      if (timeout < 0) {
        textQueue[0] = textObject;
      } else {
        textQueue.splice(1, 0, textObject);
      }
    } else {
      textQueue.unshift(textObject);
      if (timeout > 0) {
        textQueue.unshift(EMPTY);
      }
    }
  };
  const updateText = () => {
    if (currentText && currentText._timeout > 0) {
      currentText._timeout -= gameTimeDelta;
    }
    if (currentText._timeout < 0 && textQueue[0]) {
      currentText = textQueue.pop();
      gameTextElement.innerHTML = currentText._text;
    }
  };
  const GAME_STATE = {
    _gameEnded: false,
    _bioVisible: -1,
    _foundCount: 0,
    _floppies: [newFloppy(-46.5, 1.01, -25)]
  };
  function newFloppy(x, y, z, _lookAtDistance = 2) {
    return {
      _location: {x, y, z},
      _visible: true,
      _lookAtDistance,
      _onLookAt: () => "Pick up the floppy [press E or Space]",
      _onInteract() {
        this._visible = false;
        ++GAME_STATE._foundCount;
        GAME_STATE._bioVisible = GAME_STATE._floppies.indexOf(this);
      }
    };
  }
  const getVisibleObject = () => {
    const floppies = GAME_STATE._floppies;
    for (let i = 0; i < floppies.length; ++i) {
      const floppy = floppies[i];
      if (floppy._visible) {
        const objectLocation = floppy._location;
        if (vec3Distance(objectLocation, cameraPos) <= floppy._lookAtDistance) {
          if (vec3Dot(cameraDir, vec3Direction(vec3Temp0, cameraPos, objectLocation)) > 0.9) {
            return floppy;
          }
        }
      }
    }
    return void 0;
  };
  const endGame = () => {
    GAME_STATE._gameEnded = true;
    vec3Set(cameraPos, 5.844, 14.742, 4);
    vec2Set(cameraEuler, -90 * DEG_TO_RAD, 17 * DEG_TO_RAD);
  };
  const updateGameObjects = () => {
    if (!bioHtmlVisible && !GAME_STATE._gameEnded && GAME_STATE._foundCount >= GAME_STATE._floppies.length) {
      endGame();
    } else {
      const visibleObject = getVisibleObject();
      setText(visibleObject && visibleObject._onLookAt && visibleObject._onLookAt() || "");
      if (visibleObject && PressedKeys[KEY_ACTION] && visibleObject._onInteract) {
        visibleObject._onInteract();
      }
    }
  };
  const CAMERA_SPEED_DEFAULT = 2.1;
  const CAMERA_SPEED_RUN = 5.5;
  const cameraPos = vec3New(103, 44, 9);
  let headBob = 0;
  const cameraEuler = vec2New(-102 * DEG_TO_RAD, 23 * DEG_TO_RAD);
  const cameraDir = vec3NewValue();
  const cameraMat3 = new Float32Array(9);
  const movementForward = (direction) => vec3Add(vec3Temp0, vec3ScalarMultiply(vec3Normalize(vec3Set(vec3Temp1, cameraDir.x, 0, cameraDir.z)), direction));
  const movementStrafe = (direction) => vec3Add(vec3Temp0, vec3ScalarMultiply(vec3Normalize(vec3Cross(vec3Temp1, cameraDir, VEC3_UNIT_Y)), direction));
  const updateCameraDirFromEulerAngles = () => {
    let {x: yaw, y: pitch} = cameraEuler;
    if (RUMBLING) {
      yaw += sin(gameTime * 100) * 5e-3;
      pitch += sin(gameTime * 200) * 5e-3;
    }
    const sinYaw = sin(yaw);
    const cosYaw = cos(yaw);
    const sinPitch = sin(pitch);
    const cosPitch = cos(pitch);
    vec3Normalize(vec3Set(cameraDir, sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch));
    typedArraySet(cameraMat3, cosYaw, 0, -sinYaw, sinYaw * sinPitch, cosPitch, cosYaw * sinPitch, sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);
  };
  let timeMoving = 0;
  const updateCamera = () => {
    const speed = (PressedKeys[KEY_RUN] ? CAMERA_SPEED_RUN : CAMERA_SPEED_DEFAULT) * gameTimeDelta;
    if (!GAME_STATE._gameEnded && GAME_STATE._bioVisible < 0) {
      vec3Set(vec3Temp0, 0, 0, 0);
      if (PressedKeys[KEY_FORWARD]) {
        movementForward(1);
      }
      if (PressedKeys[KEY_BACKWARD]) {
        movementForward(-1);
      }
      if (PressedKeys[KEY_STRAFE_LEFT]) {
        movementStrafe(-1);
      }
      if (PressedKeys[KEY_STRAFE_RIGHT]) {
        movementStrafe(1);
      }
      if (vec3Temp0.x || vec3Temp0.z) {
        timeMoving += gameTimeDelta;
        headBob = headBobEnabled ? sin(timeMoving * 10) * 0.03 : 0;
        vec3Add(cameraPos, vec3ScalarMultiply(vec3Normalize(vec3Temp0), speed));
      }
    }
    updateCameraDirFromEulerAngles();
  };
  updateCameraDirFromEulerAngles();
  onmousemove = (e) => {
    if (document.pointerLockElement === canvasElement && !GAME_STATE._gameEnded) {
      const sens = lerp(4e-4, 31e-4, mouseSensitivity);
      cameraEuler.x = wrapAngleInRadians(cameraEuler.x - e.movementX * sens);
      cameraEuler.y = clamp(cameraEuler.y + e.movementY * mouseYInversion * sens, -87 * DEG_TO_RAD, 87 * DEG_TO_RAD);
    }
  };
  const bios_sp_html = '<ul>\n  <li>Bio html example</li>\n  <li>A bio goes here.</li>\n  <img src="./src/bios/sp.jpg">\n</ul>';
  const body = document.body;
  const canvasElement = document.getElementById("C");
  const gameTextElement = document.getElementById("T");
  const foundTextElement = document.getElementById("found-text");
  const MAIN_ELEMENT_PADDING = 30;
  const MAIN_ELEMENT_ASPECT_RATIO = 1.5;
  const MAIN_ELEMENT_MAX_WIDTH = 2e3;
  let mainMenuVisible;
  let renderWidth;
  let renderHeight;
  let mouseYInversion = 1;
  let headBobEnabled = true;
  let mouseSensitivity = 0.5;
  const mainElement = document.getElementById("M");
  const newGameButton = document.getElementById("R");
  const highQualityCheckbox = document.getElementById("Q");
  const invertYCheckbox = document.getElementById("Y");
  const mouseSensitivitySlider = document.getElementById("V");
  const headBobCheckbox = document.getElementById("H");
  const bioHtmlContentDiv = document.getElementById("bioc");
  const saveGameButton = document.getElementById("S");
  const loadGameButton = document.getElementById("L");
  const handleResize = () => {
    let cw = min(MAIN_ELEMENT_MAX_WIDTH, innerWidth - MAIN_ELEMENT_PADDING);
    let ch = innerHeight - MAIN_ELEMENT_PADDING;
    if (MAIN_ELEMENT_ASPECT_RATIO >= cw / ch) {
      ch = cw / MAIN_ELEMENT_ASPECT_RATIO;
    } else {
      cw = ch * MAIN_ELEMENT_ASPECT_RATIO;
    }
    const whStyles = {width: cw | 0, height: ch | 0, fontSize: `${ch / 23 | 0}px`};
    objectAssign(mainElement.style, whStyles);
    objectAssign(canvasElement.style, whStyles);
    let {clientWidth: w, clientHeight: h} = mainElement;
    if (!highQualityCheckbox.checked) {
      w = w / 2 | 0;
      h = h / 2 | 0;
    }
    renderWidth = w;
    renderHeight = h;
    canvasElement.width = w;
    canvasElement.height = h;
  };
  const showMainMenu = () => {
    mainMenuVisible = true;
    body.classList.add("N");
    document.exitPointerLock();
  };
  document.onpointerlockchange = () => {
    if (!document.pointerLockElement) {
      {
        showMainMenu();
      }
    }
  };
  const canvasRequestPointerLock = (e) => (!e || !e.button) && !mainMenuVisible && canvasElement.requestPointerLock();
  let gameStarted;
  const startOrResumeClick = (newGame = true) => {
    if (!gameStarted) {
      saveGameButton.className = "";
      if (newGame) {
        resetHtmlState();
        setText("Find all the floppy disks!", 2);
      }
      newGameButton.innerText = "Resume Game";
      vec3Set(cameraPos, -44, 4, 11);
      vec2Set(cameraEuler, 70 * DEG_TO_RAD, 0 * DEG_TO_RAD);
      gameStarted = true;
    }
    mainMenuVisible = false;
    body.classList.remove("N");
    canvasRequestPointerLock();
  };
  handleResize();
  onresize = handleResize;
  newGameButton.onclick = () => startOrResumeClick();
  KeyFunctions[KEY_MAIN_MENU] = showMainMenu;
  KeyFunctions[KEY_ACTION] = (repeat) => {
    if (!repeat) {
      GAME_STATE._bioVisible = -1;
    }
  };
  canvasElement.onmousedown = canvasRequestPointerLock;
  gameTextElement.onmousedown = canvasRequestPointerLock;
  highQualityCheckbox.onchange = handleResize;
  invertYCheckbox.onchange = () => {
    mouseYInversion = invertYCheckbox.checked ? -1 : 1;
  };
  headBobCheckbox.onchange = () => {
    headBobEnabled = headBobCheckbox.checked;
  };
  mouseSensitivitySlider.onchange = () => {
    mouseSensitivity = parseInt(mouseSensitivitySlider.value) / 100;
  };
  const gl = canvasElement.getContext("webgl2", {
    alpha: false,
    desynchronized: true,
    antialias: false,
    depth: false,
    failIfMajorPerformanceCaveat: false,
    powerPreference: "high-performance",
    preserveDrawingBuffer: false,
    stencil: false
  });
  const glFrameBuffer = gl.createFramebuffer();
  let bioHtmlVisible = null;
  let _foundHtmlCount = -2;
  function resetHtmlState() {
    bioHtmlVisible = null;
    _foundHtmlCount = -2;
  }
  function updateBio() {
    if (_foundHtmlCount !== GAME_STATE._foundCount) {
      const floppiesCount = GAME_STATE._floppies.length;
      _foundHtmlCount = GAME_STATE._foundCount;
      if (_foundHtmlCount >= floppiesCount) {
        foundTextElement.innerHTML = "<br/><h1>Congratulations!<br/>You found all the joiners!</h1>";
      } else {
        foundTextElement.innerText = `Found ${_foundHtmlCount} of ${floppiesCount} floppies.`;
      }
    }
    const bioVisible = !mainMenuVisible && GAME_STATE._bioVisible >= 0;
    if (bioHtmlVisible !== bioVisible) {
      bioHtmlVisible = bioVisible;
      if (bioHtmlVisible) {
        body.classList.add("bio");
        bioHtmlContentDiv.innerHTML = bios_sp_html;
      } else {
        body.classList.remove("bio");
      }
    }
  }
  const GL_TRIANGLES = 4;
  const GL_NICEST = 4354;
  const GL_GENERATE_MIPMAP_HINT = 33170;
  const GL_UNSIGNED_BYTE = 5121;
  const GL_RGBA = 6408;
  const GL_FRAGMENT_SHADER = 35632;
  const GL_VERTEX_SHADER = 35633;
  const GL_NEAREST = 9728;
  const GL_LINEAR = 9729;
  const GL_LINEAR_MIPMAP_LINEAR = 9987;
  const GL_TEXTURE_MAG_FILTER = 10240;
  const GL_TEXTURE_MIN_FILTER = 10241;
  const GL_TEXTURE_WRAP_S = 10242;
  const GL_TEXTURE_WRAP_T = 10243;
  const GL_TEXTURE_2D = 3553;
  const GL_TEXTURE0 = 33984;
  const GL_TEXTURE1 = 33985;
  const GL_TEXTURE2 = 33986;
  const GL_TEXTURE5 = 33989;
  const GL_REPEAT = 10497;
  const GL_CLAMP_TO_EDGE = 33071;
  const GL_FRAMEBUFFER = 36160;
  const GL_COLOR_ATTACHMENT0 = 36064;
  const glSetTextureSampling = (wrap = GL_REPEAT, minFilter = GL_LINEAR, magFilter = minFilter) => {
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap);
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap);
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
    gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
  };
  const code = "#version 300 es\nprecision mediump int;uniform vec2 iR;out vec2 FC;void main(){vec2 a=vec2(float((gl_VertexID&1)<<2),float((gl_VertexID&2)<<1));gl_Position=vec4(a-1.,0.,1.);FC=a*iR*.5;}";
  const code$1 = "#version 300 es\nprecision highp float;in vec2 FC;uniform vec2 iR;uniform vec3 iP;uniform vec4 iD;uniform vec4 iS;uniform mat3 iM;uniform int iF0;out vec4 oC;uniform highp sampler2D tN;uniform highp sampler2D tH;uniform highp sampler2D tP;float a;float b(float a){return clamp(a,0.,1.);}float c(float a,float b,float c){float d=max(c-abs(a-b),0.)/c;return min(a,b)-d*d*c/4.;}vec4 d(float a){vec4 c=b(a)*vec4(.999998,254.99948,65024.867,160581056);c=fract(c);c-=c.yzww*vec4(.003921569,.003921569,.003921569,0);return c;}float e(vec4 a){return dot(a,vec4(1,.003921569,1.53787e-5,6.2273724e-9));}vec3 f(vec2 a){vec4 b=texelFetch(tN,ivec2(floor(a))&511,0);float c=b.y-b.x,d=b.z-b.x,e=b.w-c-b.z;vec2 f=fract(a),g=f*f,h=g*(3.-2.*f);return vec3(b.x+c*h.x+d*h.y+e*h.x*h.y,30.*g*(f*(f-2.)+1.)*(vec2(c,d)+e*h.yx));}int g=0;float h=150.;void i(int b,float c){if(c<a&&c!=h){g=b;h=c;}}float j(vec3 a,vec3 b){vec3 c=abs(a)-b;return min(max(c.x,max(c.y,c.z)),0.)+length(max(c,0.));}mat2 k(float a){float b=cos(a),c=sin(a);return mat2(b,c,-c,b);}float l(vec3 a){float b=j(a-vec3(.056,0,0),vec3(.035,.006,.05)),c=j(a,vec3(.09,.005,.0937));if(c<b){i(2,c);return c;}i(1,b);return b;}float m(vec3 a){vec3 b=abs(vec3(a.x,a.y+3.,a.z))-vec3(60,0,39);if(b.x<0.&&b.z<0.){float c=e(textureLod(tH,a.xz/vec2(120,78)+.5,0.)),d=1.-c;b.y-=c*19.+d*d*d;}return min(b.y,0.)+length(max(b,0.));}float n(vec3 a){float b=j(a-vec3(-47,.5,-26),vec3(1,.5,3)),c=150.;if((iF0&1)!=0)c=min(c,l(a-vec3(-46.5,1.01,-25)));float d=b;if(c<d)return c;i(0,d);return d;}int o=0;float p(vec3 b){float c=m(b);if(c>a){float a=n(b);if(c>=a){o=2;return a;}}o=1;return c;}vec3 q(vec3 a){return normalize(vec3(n(a+vec3(.001,0,0)),n(a+vec3(0,.001,0)),n(a+vec3(0,0,.001)))-n(a));}vec3 r(vec3 a,float b){vec2 c=vec2(mix(.03,.001,min(b/120.,1.)),0);return normalize(vec3(m(a+c.xyy),m(a+c.yxy),m(a+c.yyx))-m(a));}float s(vec3 b,vec3 c,float d,float e){float f=d;for(int g=0;;g++){vec3 h=b+c*e;a=d*max(e,1.);if(h.y<=-2.9995||e>=150.){float a=(-3.-b.y)/c.y;if(a>=0.&&a<500.){o=1;return a;}break;}if(h.y>45.)break;float i=p(h);if(i<0.){e-=f;i=f/2.;}e+=i;if(i<=a||g>=100)return e;f=i;}o=0;return 500.;}float t(vec3 b,float c,vec3 d,float e){float f=clamp(c*.005,.01,.1);b=b+d*f;float g=iS.w-a*2.;for(float h=1.;h<50.;h++){vec3 c=b+iS.xyz*f;if(f>=80.||c.y>45.||c.y<g||length(b)>=150.)break;float d=n(c),i=max(a,.01*min(1.,f)+h*2e-4);if(d<=i)return 0.;e=min(e,85.*d/f);if(e<.078)return 0.;f+=d+a;}return e;}float u(vec3 a,vec3 b){float c=(iS.w-a.y)/b.y;return min(c>=0.?c:500.,500.);}vec3 v(vec2 a){vec3 b=vec3(0);float c=0.,d=1.,e=0.,g=1.-length(iP.xz-a)/500.,h=5.*g*g;for(float i=0.;i<h;++i){a+=iD.w*.5;e*=-.75;vec3 g=f(a+sin(a.yx*.5+iD.w*.5)*.5);b+=g*d;a+=g.yz*.43;a*=2.;c+=d;d*=.75;}return b/c;}vec3 w(vec3 a,float c,vec3 d){float e=min(c/500.,1.),f=b(pow(e,3.5)+1.-exp(-c*.005)),g=max(dot(d,iS.xyz),0.);vec3 h=mix(vec3(.4,.8,1),vec3(1.065,.95,.85),pow(g,10.));return mix(a,h,f);}vec3 x(vec3 a,vec3 c){vec4 d=texelFetch(tP,ivec2(FC*256./iR),0);float e=uintBitsToFloat(uint(d.x*255.)<<24|uint(d.y*255.)<<16|uint(d.z*255.)<<8|uint(d.z*255.)),f=s(a,c,.001,e),h=u(a,c);vec3 i,j=vec3(0,1,0);float k=f;vec3 l=a+c*f;bool m=h<500.&&h<f;vec3 n;float p=0.;if(m){p=mix(.2,1.,b((f-h)/3.));vec3 d=a+c*h,e=mix(vec3(0),v(d.xz*(.7-iS.w*.02))*(1.-length(d)/450.),p);j=normalize(vec3(e.y,1.,e.x));h-=abs(e.z)*p*.6;k=h;n=mix(vec3(.25,.52,.73),vec3(.15,.62,.83),b(abs(e.z)-p));}int x=o,y=g;if(o==0)i=vec3(.4,.8,1);else{vec3 a;if(l.y<=-2.9995){a=vec3(0,1,0);i=vec3(1);}else{i=vec3(.8);switch(x){case 1:a=r(l,f);i=mix(vec3(.93,.8,.64),mix(vec3(.69+texture(tN,l.xz*1e-4).x,.67,.65),vec3(.38,.52,.23),dot(a,vec3(0,1,0))),b(l.y*.5-1.))+texture(tN,l.xz*.15).x*.1+texture(tN,l.xz*.01).y*.1;break;case 2:a=q(l);switch(y){case 1:i=vec3(1);break;case 2:i=vec3(1,0,0);break;case 3:i=vec3(.5,0,0);break;case 4:i=vec3(.2,.1,.2);break;case 5:i=vec3(1,.95,.8);break;case-1:i=vec3(.64000005,.48000002,.32000002);break;default:vec4 b=texture(tN,l.xy*.35)*a.z+texture(tN,l.yz*.35)*a.x+texture(tN,l.xz*.35)*a.y-.5;i+=.125*(b.x-b.y+b.z-b.w);break;}}j=normalize(mix(a,j,p));}}float z=m||x==2&&y>0?pow(b(dot(iS.xyz,reflect(c,j))),50.):0.,A=b(dot(iS.xyz,j)),B=b(dot(iS.xyz*vec3(-1,1,-1),j)),C=A+B*.15;if(x==1)C=pow(C*mix(.9,1.02,A*A),1.+A*.6);C=mix(C,A,p);float D=1.;if(o!=0)D=t(a+c*k,k,j,1.);i=mix(i,n,p);i=(i*vec3(1.065,.95,.85)*C+z)*mix(.38+(1.-C)*.2,1.,D);return w(i,k,c);}void main_c(){vec3 a=vec3(0,0,1);a.xz*=k(FC.x*.049087387+3.1415927);oC=d(.2-p(vec3(iP.x,iP.y+(FC.y/64.-1.)-.8,iP.z)+normalize(a)*.15));}void main_p(){vec2 b=FC/128.-1.+.001953125;vec3 c=normalize(iM*vec3(b.x*-1.5,b.y,2.4142134));float d=s(iP,c,.0046875,.15);uint e=floatBitsToUint(d>=150.?150.:d-a);oC=vec4(float(e>>24&255u)/255.,float(e>>16&255u)/255.,float(e>>8&255u)/255.,float(e&255u)/255.);}void main_m(){vec2 a=FC/(iR*.5)-1.;vec3 b=normalize(iM*vec3(a.x*-1.5,a.y,2.4142134));oC=vec4(x(iP,b),1);}float y(vec2 a,float c,float d,float e,float f){vec2 g=a-vec2(c,d);return b(1.-smoothstep(e-e*f,e,dot(g,g)*4.));}void main_h(){vec2 a=FC/(iR*.5)-1.,e=vec2(1.3,1),g=vec2(0);float h=0.,i=1.,j=1.,l=0.,m=1.;while(m<11.){vec3 b=f(21.1+a*e*k(m++*2.5));g+=b.yz;h+=j*(1.-b.x)/(1.+dot(g,g));i+=j*(.5-b.x);l+=j;j*=.5;e*=1.8;}h/=l;i*=.5;float n=length(a*(1.2-i+h))*b(i+.56-.5*h*a.x*(1.-a.y*.5)),o=y(a,-.45,-.52,1.,2.3)+y(a,-.6,-.1,1.,3.3)+y(a,.5,-.7,1.,5.)+y(a,.6,.53,h*2.,i*5.);n=b(1.-c(n,1.-mix(0.,h*2.,o),.05+i*.5));vec2 p=1.-abs(a)+h*.04;n=c(n,c(p.x,p.y,.3)*2.,.1);oC=d(c(h,n,.01)*1.33-.045);}";
  const loadShaderFunction = (mainFunction) => {
    const program = gl.createProgram();
    const loadShaderCode = (type, sourceCode) => {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, sourceCode);
      gl.compileShader(shader);
      gl.attachShader(program, shader);
      return shader;
    };
    const vertexShader = loadShaderCode(GL_VERTEX_SHADER, code);
    const fragmentShader = loadShaderCode(GL_FRAGMENT_SHADER, code$1.replace(`main_${mainFunction}`, "main"));
    gl.linkProgram(program);
    gl.useProgram(program);
    const iNoise = gl.getUniformLocation(program, "tN");
    const iHeightmap = gl.getUniformLocation(program, "tH");
    const iPrerendered = gl.getUniformLocation(program, "tP");
    const iResolution = gl.getUniformLocation(program, "iR");
    const iCameraMat3 = gl.getUniformLocation(program, "iM");
    const iSunDirection = gl.getUniformLocation(program, "iS");
    const iP = gl.getUniformLocation(program, "iP");
    const iD = gl.getUniformLocation(program, "iD");
    const iF0 = gl.getUniformLocation(program, "iF0");
    [iNoise, iHeightmap, iPrerendered].map((t, i) => gl.uniform1i(t, i));
    const useShader = (width, height, isCollider) => {
      gl.viewport(0, 0, width, height);
      gl.useProgram(program);
      gl.uniform2f(iResolution, width, height);
      const waterLevel = sin(gameTime * 2 + 3) * 0.2;
      vec3Normalize(vec3Set(vec3Temp0, 0.4 + cos(gameTime * 0.02) * 0.1, 0.44 + sin(gameTime * 0.02) * 0.1 - 0.05, -0.38));
      gl.uniform4f(iSunDirection, vec3Temp0.x, vec3Temp0.y, vec3Temp0.z, waterLevel);
      gl.uniform3f(iP, cameraPos.x, cameraPos.y + (isCollider ? 0 : headBob), cameraPos.z);
      gl.uniform4f(iD, cameraDir.x, cameraDir.y, cameraDir.z, gameTime);
      gl.uniformMatrix3fv(iCameraMat3, false, cameraMat3);
      let floppiesMask = 0;
      const floppies = GAME_STATE._floppies;
      for (let i = 0; i < floppies.length; ++i) {
        floppiesMask |= floppies[i]._visible ? 1 << i : 0;
      }
      gl.uniform1i(iF0, floppiesMask);
    };
    return useShader;
  };
  let mainShader;
  let collisionShader;
  let prerenderedShader;
  const loadMainShader = () => {
    mainShader = loadShaderFunction("m");
    collisionShader = loadShaderFunction("c");
    prerenderedShader = loadShaderFunction("p");
  };
  const HEIGHTMAP_TETURE_SIZE = 4096;
  const heightmapTexture = gl.createTexture();
  const buildHeightmapTexture = () => {
    gl.activeTexture(GL_TEXTURE1);
    gl.bindTexture(GL_TEXTURE_2D, heightmapTexture);
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, HEIGHTMAP_TETURE_SIZE, HEIGHTMAP_TETURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, null);
    gl.bindFramebuffer(GL_FRAMEBUFFER, glFrameBuffer);
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, heightmapTexture, 0);
    loadShaderFunction("h")(HEIGHTMAP_TETURE_SIZE, HEIGHTMAP_TETURE_SIZE);
    gl.drawArrays(GL_TRIANGLES, 0, 3);
    gl.generateMipmap(GL_TEXTURE_2D);
    glSetTextureSampling(GL_CLAMP_TO_EDGE, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
    gl.bindFramebuffer(GL_FRAMEBUFFER, null);
  };
  const NOISE_TEXTURE_SIZE = 512;
  const noiseTexture = gl.createTexture();
  const buildNoiseTexture = () => {
    gl.activeTexture(GL_TEXTURE0);
    gl.bindTexture(GL_TEXTURE_2D, noiseTexture);
    const data2 = new Uint8Array(NOISE_TEXTURE_SIZE * NOISE_TEXTURE_SIZE * 4);
    let xoshiroA = 345;
    let xoshiroB = 737;
    let xoshiroC = 1082;
    let xoshiroD = 254265;
    for (let y = 0; y < NOISE_TEXTURE_SIZE; ++y) {
      const ay = y * (NOISE_TEXTURE_SIZE * 4);
      const by = ((y - 1) % NOISE_TEXTURE_SIZE + NOISE_TEXTURE_SIZE) % NOISE_TEXTURE_SIZE * (NOISE_TEXTURE_SIZE * 4);
      for (let x = 0; x < NOISE_TEXTURE_SIZE; ++x) {
        const t = xoshiroB << 9;
        let xoshiro = xoshiroA * 5;
        xoshiro = (xoshiro << 7 | xoshiro >>> 25) * 9;
        xoshiroC ^= xoshiroA;
        xoshiroD ^= xoshiroB;
        xoshiroB ^= xoshiroC;
        xoshiroA ^= xoshiroD;
        xoshiroC ^= t;
        xoshiroD = xoshiroD << 11 | xoshiroD >>> 21;
        xoshiro &= 255;
        const ax = x * 4;
        const bx = ((x - 1) % NOISE_TEXTURE_SIZE + NOISE_TEXTURE_SIZE) % NOISE_TEXTURE_SIZE * 4;
        data2[ax + ay] = xoshiro;
        data2[bx + ay + 1] = xoshiro;
        data2[ax + by + 2] = xoshiro;
        data2[bx + by + 3] = xoshiro;
      }
    }
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, data2);
    gl.hint(GL_GENERATE_MIPMAP_HINT, GL_NICEST);
    gl.generateMipmap(GL_TEXTURE_2D);
    glSetTextureSampling(GL_REPEAT, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
  };
  const CAMERA_MAX_DISTANCE_FROM_CENTER = 100;
  const COLLIDER_SIZE = 128;
  const colliderTexture = gl.createTexture();
  const colliderFrameBuffer = gl.createFramebuffer();
  const colliderBuffer = new Uint8Array(COLLIDER_SIZE * COLLIDER_SIZE * 4);
  const readDist = (x, y) => {
    const bufIdx = y * COLLIDER_SIZE * 4 + x * 4;
    return unpackFloatBytes4(colliderBuffer[bufIdx], colliderBuffer[bufIdx + 1], colliderBuffer[bufIdx + 2], colliderBuffer[bufIdx + 3]);
  };
  const getAngleFromIdx = (x) => -(PI * (x - 64) / 64) - PI / 2;
  const initCollider = () => {
    gl.activeTexture(GL_TEXTURE5);
    gl.bindTexture(GL_TEXTURE_2D, colliderTexture);
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, COLLIDER_SIZE, COLLIDER_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, null);
    gl.bindFramebuffer(GL_FRAMEBUFFER, colliderFrameBuffer);
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colliderTexture, 0);
  };
  const updateCollider = () => {
    collisionShader(COLLIDER_SIZE, COLLIDER_SIZE, true);
    gl.bindFramebuffer(GL_FRAMEBUFFER, colliderFrameBuffer);
    gl.drawArrays(GL_TRIANGLES, 0, 3);
    gl.readPixels(0, 0, COLLIDER_SIZE, COLLIDER_SIZE, GL_RGBA, GL_UNSIGNED_BYTE, colliderBuffer);
    gl.bindFramebuffer(GL_FRAMEBUFFER, null);
    let totalY = 0;
    for (let x = 0; x < 128; x++) {
      let maxY = -99;
      for (let y = 0; y < 32; y++) {
        maxY = max(readDist(x, y), maxY);
      }
      totalY += maxY;
    }
    const ddy = totalY / 128 - 0.2;
    let ddx = 0;
    let ddz = 0;
    for (let y = 32; y < 96; ++y) {
      for (let x1 = 0; x1 < 64; ++x1) {
        const x2 = x1 + 64;
        const dist1 = readDist(x1, y);
        const dist2 = readDist(x2, y);
        const angle1 = getAngleFromIdx(x1);
        const angle2 = getAngleFromIdx(x2);
        const dx = cos(angle1) * dist1 + cos(angle2) * dist2;
        const dz = sin(angle1) * dist1 + sin(angle2) * dist2;
        if (abs(dx) > abs(ddx)) {
          ddx = dx;
        }
        if (abs(dz) > abs(ddz)) {
          ddz = dz;
        }
      }
    }
    cameraPos.x += ddx;
    cameraPos.y = max(cameraPos.y + ddy, 0.9);
    cameraPos.z += ddz;
    const distanceFromCenter = vec3Length(cameraPos);
    if (distanceFromCenter >= CAMERA_MAX_DISTANCE_FROM_CENTER) {
      cameraPos.x *= CAMERA_MAX_DISTANCE_FROM_CENTER / distanceFromCenter;
      cameraPos.z *= CAMERA_MAX_DISTANCE_FROM_CENTER / distanceFromCenter;
    }
  };
  const PRERENDERED_TEXTURE_SIZE = 256;
  const prerenderedTexture = gl.createTexture();
  const initPrerenderedTexture = () => {
    gl.activeTexture(GL_TEXTURE2);
    gl.bindTexture(GL_TEXTURE_2D, prerenderedTexture);
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, PRERENDERED_TEXTURE_SIZE, PRERENDERED_TEXTURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, null);
    glSetTextureSampling(GL_CLAMP_TO_EDGE, GL_NEAREST);
    gl.bindFramebuffer(GL_FRAMEBUFFER, glFrameBuffer);
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, prerenderedTexture, 0);
    gl.bindFramebuffer(GL_FRAMEBUFFER, null);
  };
  const data = [GAME_STATE, ANIMATIONS, cameraPos, cameraEuler];
  function deepMerge(original, item) {
    for (const key in item) {
      if (typeof item[key] === "object") {
        deepMerge(original[key], item[key]);
      } else {
        original[key] = item[key];
      }
    }
  }
  const LOCAL_STORAGE_KEY = "joiners30-12-20";
  const SAVE_GAME = () => {
    if (gameStarted) {
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
      setText("Saved", 2);
      startOrResumeClick(false);
      loadGameButton.className = "";
    }
  };
  const getDataFromLocalStorage = () => localStorage.getItem(LOCAL_STORAGE_KEY);
  const LOAD_GAME = () => {
    const savedGame = getDataFromLocalStorage();
    if (savedGame) {
      clearTexts();
      startOrResumeClick(false);
      deepMerge(data, JSON.parse(savedGame));
      setText("Game loaded", 2);
    }
  };
  saveGameButton.onclick = SAVE_GAME;
  loadGameButton.onclick = LOAD_GAME;
  loadGameButton.className = getDataFromLocalStorage() ? "" : "X";
  setTimeout(() => {
    buildNoiseTexture();
    buildHeightmapTexture();
    initPrerenderedTexture();
    initCollider();
    loadMainShader();
    showMainMenu();
    const animationFrame = debug_trycatch_wrap((browserTimeInMilliseconds) => {
      requestAnimationFrame(animationFrame);
      if (!updateTime(browserTimeInMilliseconds, mainMenuVisible)) {
        return;
      }
      updateCamera();
      if (!mainMenuVisible) {
        if (!GAME_STATE._gameEnded && !GAME_STATE._bioVisible) {
          updateCollider();
        }
        updateAnimations();
        updateGameObjects();
        updateText();
      }
      prerenderedShader(PRERENDERED_TEXTURE_SIZE, PRERENDERED_TEXTURE_SIZE);
      gl.bindFramebuffer(GL_FRAMEBUFFER, glFrameBuffer);
      gl.drawArrays(GL_TRIANGLES, 0, 3);
      gl.bindFramebuffer(GL_FRAMEBUFFER, null);
      mainShader(renderWidth, renderHeight);
      gl.drawArrays(GL_TRIANGLES, 0, 3);
      updateBio();
    });
    requestAnimationFrame(animationFrame);
  }, 99);
})();}
__js_load_modules__();</script></body></html>